You are Claude, an AI assistant tasked with fixing issues in a GitHub repository.

Issue #456: [claude-fix] Issue #455: CRITICAL - Complete Diagnostic Trace and Fix for All Remaining Failures

Issue Description:
<html>
<body>
<!--StartFragment--><html><head></head><body><h1>Issue #455: CRITICAL - Complete Diagnostic Trace and Fix for All Remaining Failures</h1>
<h2>üö® SEVERITY: CRITICAL - BLOCKING RELEASE</h2>
<p><strong>Current State:</strong> 7 tests failing (87% pass rate)
<strong>Required State:</strong> 0 tests failing (100% pass rate)</p>
<p>PR #454 partially worked (greetings fixed, TRUTH-018 fixed) but 7 tests still fail. The code was added but <strong>is not executing as expected</strong>. This issue requires:</p>
<ol>
<li><strong>DIAGNOSTIC LOGGING</strong> at every decision point</li>
<li><strong>ROOT CAUSE IDENTIFICATION</strong> for each failure</li>
<li><strong>COMPLETE FIX</strong> with verification</li>
<li><strong>BIBLE ALIGNMENT</strong> verification for every change</li>
</ol>
<hr>
<h2>üìú BIBLE ALIGNMENT REQUIREMENTS (NON-NEGOTIABLE)</h2>
<p>Every fix MUST align with these doctrines from the 4 foundational documents:</p>
<h3>From Master Specification:</h3>
<blockquote>
<p>"Truth &gt; Helpfulness &gt; Engagement - This is the NON-NEGOTIABLE hierarchy"
"Act like an extraordinarily intelligent, caring family member who has world-class expertise"</p>
</blockquote>
<h3>From Technical Standards:</h3>
<blockquote>
<p>"Token efficiency isn't optional optimization but foundational architecture"
"Comprehensive, surgical solutions work better than incremental fixes"</p>
</blockquote>
<h3>From Complete Specification:</h3>
<blockquote>
<p><strong>Innovation #3:</strong> "When new information contradicts old, system identifies which is more recent/reliable and updates accordingly"
<strong>Innovation #7:</strong> "Every memory entry has associated importance score... Critical facts (allergies, medical) get highest priority"
<strong>Innovation #8:</strong> "Semantic + Mode-Aware Indexing - memories tagged with mode context"
<strong>Innovation #22:</strong> "Cross-Mode Transfer Gateway - controlled mechanism for sharing context between modes"
<strong>Innovation #46:</strong> "Users can view what system remembers about them"</p>
</blockquote>
<h3>From Implementation Roadmap:</h3>
<blockquote>
<p>"One mishap kills your patient - neurosurgical precision required"
"Never assume code works - verify with logs"</p>
</blockquote>
<hr>
<h2>üî¥ FAILING TESTS (7 Total)</h2>

Test | Innovation | Current Behavior | Required Behavior
-- | -- | -- | --
MEM-003 | #3 | Returns old salary ($80K) | Must return new salary ($95K)
MEM-007 | #7 | Returns preference, ignores allergy | Must return allergy FIRST
INJ-008 | #8 | Mode-specific memory not found | Must retrieve mode-specific memories
MODE-022 | #22 | Context not transferred | Must transfer context between modes
UX-044 | #44 | Cross-session fails | Must persist across sessions
UX-046 | #46 | Prose summary | Must show structured memory list
UX-049 | #49 | Doesn't learn priorities | Must learn and apply user priorities


<hr>
<h2>üîç PHASE 1: DIAGNOSTIC LOGGING</h2>
<p>Before ANY fixes, add diagnostic logging to trace exactly what's happening.</p>
<h3>1.1 Supersession Diagnostics (MEM-003)</h3>
<p><strong>File:</strong> <code>api/services/supersession.js</code></p>
<p>Add logging at the START of fingerprint detection:</p>
<pre><code class="language-javascript">export async function detectFingerprint(content) {
  console.log('[SUPERSESSION-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('[SUPERSESSION-DIAG] Input content:', content.substring(0, 100));
  console.log('[SUPERSESSION-DIAG] Content length:', content.length);
  
  // Log each pattern check
  for (const patternDef of FINGERPRINT_PATTERNS) {
    console.log(`[SUPERSESSION-DIAG] Checking pattern: ${patternDef.fingerprint}`);
    for (let i = 0; i &lt; patternDef.patterns.length; i++) {
      const pattern = patternDef.patterns[i];
      const match = content.match(pattern);
      console.log(`[SUPERSESSION-DIAG]   Pattern ${i}: ${pattern.toString().substring(0, 50)}...`);
      console.log(`[SUPERSESSION-DIAG]   Match: ${match ? 'YES - ' + match[0] : 'NO'}`);
      if (match) {
        console.log(`[SUPERSESSION-DIAG] ‚úÖ PATTERN MATCH FOUND: ${patternDef.fingerprint}`);
        return {
          fingerprint: patternDef.fingerprint,
          confidence: patternDef.confidence,
          method: 'pattern',
          matchedPattern: i,
          matchedText: match[0]
        };
      }
    }
  }
  
  console.log('[SUPERSESSION-DIAG] ‚ùå No pattern matches, falling through to model...');
  // ... rest of function
}
</code></pre>
<h3>1.2 Memory Visibility Diagnostics (UX-046)</h3>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code></p>
<p>Add logging at the START of processRequest:</p>
<pre><code class="language-javascript">async processRequest(message, options = {}) {
  console.log('[VISIBILITY-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('[VISIBILITY-DIAG] Input message:', message);
  console.log('[VISIBILITY-DIAG] Message length:', message.length);
  
  // Test each pattern individually
  const memoryVisibilityPatterns = [
    /what do you (?:remember|know) about me/i,
    /show (?:me )?(?:my )?memor(?:y|ies)/i,
    /list (?:my |what you )?(?:remember|stored|know)/i,
    /what (?:have you |do you have )(?:stored|saved|remembered)/i,
    /my (?:stored )?(?:memories|information|data)/i
  ];
  
  for (let i = 0; i &lt; memoryVisibilityPatterns.length; i++) {
    const pattern = memoryVisibilityPatterns[i];
    const match = pattern.test(message);
    console.log(`[VISIBILITY-DIAG] Pattern ${i}: ${pattern.toString()}`);
    console.log(`[VISIBILITY-DIAG] Match: ${match}`);
  }
  
  const isMemoryVisibilityRequest = memoryVisibilityPatterns.some(p =&gt; p.test(message));
  console.log(`[VISIBILITY-DIAG] Final decision: ${isMemoryVisibilityRequest}`);
  
  if (isMemoryVisibilityRequest) {
    console.log('[VISIBILITY-DIAG] ‚úÖ TRIGGERING MEMORY VISIBILITY HANDLER');
    // ... handler code
  } else {
    console.log('[VISIBILITY-DIAG] ‚ùå NOT triggering memory visibility handler');
  }
  // ... rest of function
}
</code></pre>
<h3>1.3 Importance Scoring Diagnostics (MEM-007)</h3>
<p><strong>File:</strong> <code>api/memory/intelligent-storage.js</code></p>
<p>Add logging in calculateImportanceScore:</p>
<pre><code class="language-javascript">function calculateImportanceScore(content, category) {
  console.log('[IMPORTANCE-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('[IMPORTANCE-DIAG] Content:', content.substring(0, 100));
  console.log('[IMPORTANCE-DIAG] Category:', category);
  
  const contentLower = content.toLowerCase();
  console.log('[IMPORTANCE-DIAG] Content lowercase:', contentLower.substring(0, 100));
  
  // Check each critical keyword
  for (const keyword of CRITICAL_KEYWORDS) {
    const found = contentLower.includes(keyword);
    if (found) {
      console.log(`[IMPORTANCE-DIAG] ‚úÖ CRITICAL keyword found: "${keyword}" ‚Üí returning 0.95`);
      return 0.95;
    }
  }
  console.log('[IMPORTANCE-DIAG] No critical keywords found');
  
  // Check each high priority keyword
  for (const keyword of HIGH_PRIORITY_KEYWORDS) {
    const found = contentLower.includes(keyword);
    if (found) {
      console.log(`[IMPORTANCE-DIAG] ‚úÖ HIGH keyword found: "${keyword}" ‚Üí returning 0.80`);
      return 0.80;
    }
  }
  console.log('[IMPORTANCE-DIAG] No high priority keywords found');
  
  console.log(`[IMPORTANCE-DIAG] Defaulting based on category: ${category}`);
  // ... rest of function
}
</code></pre>
<h3>1.4 Mode-Aware Retrieval Diagnostics (INJ-008)</h3>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code></p>
<p>Add logging in buildPrefilterQuery:</p>
<pre><code class="language-javascript">function buildPrefilterQuery(options) {
  console.log('[MODE-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('[MODE-DIAG] Options:', JSON.stringify(options, null, 2));
  console.log('[MODE-DIAG] Mode from options:', options.mode);
  
  const conditions = [];
  
  // Mode filtering
  if (options.mode) {
    console.log(`[MODE-DIAG] Adding mode filter for: ${options.mode}`);
    conditions.push(`(mode = '${options.mode}' OR mode = 'truth-general' OR mode IS NULL)`);
  } else {
    console.log('[MODE-DIAG] ‚ö†Ô∏è NO MODE PROVIDED - defaulting to truth-general');
    conditions.push(`(mode = 'truth-general' OR mode IS NULL)`);
  }
  
  console.log('[MODE-DIAG] Final conditions:', conditions);
  // ... rest of function
}
</code></pre>
<h3>1.5 Cross-Mode Transfer Diagnostics (MODE-022)</h3>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code></p>
<pre><code class="language-javascript">// Add at the start of retrieval
console.log('[CROSS-MODE-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('[CROSS-MODE-DIAG] allowCrossMode:', options.allowCrossMode);
console.log('[CROSS-MODE-DIAG] Current mode:', options.mode);
console.log('[CROSS-MODE-DIAG] Previous mode (if any):', options.previousMode);

if (options.allowCrossMode) {
  console.log('[CROSS-MODE-DIAG] ‚úÖ Cross-mode transfer ENABLED');
  // Should search across modes
} else {
  console.log('[CROSS-MODE-DIAG] ‚ùå Cross-mode transfer DISABLED - strict mode isolation');
}
</code></pre>
<h3>1.6 Cross-Session Diagnostics (UX-044)</h3>
<p><strong>File:</strong> <code>server.js</code> and <code>api/memory/intelligent-storage.js</code></p>
<pre><code class="language-javascript">// In server.js at request start
console.log('[SESSION-DIAG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('[SESSION-DIAG] Headers x-user-id:', req.headers['x-user-id']);
console.log('[SESSION-DIAG] Query userId:', req.query.userId);
console.log('[SESSION-DIAG] Body userId:', req.body?.userId);
const userId = req.headers['x-user-id'] || req.query.userId || req.body?.userId || 'anonymous';
console.log('[SESSION-DIAG] Final userId:', userId);

// In intelligent-storage.js at storage
console.log('[SESSION-DIAG] Storing for userId:', userId);

// In semantic-retrieval.js at retrieval
console.log('[SESSION-DIAG] Retrieving for userId:', userId);
</code></pre>
<hr>
<h2>üîß PHASE 2: ROOT CAUSE ANALYSIS</h2>
<p>After deploying diagnostic logging, analyze the logs to identify root causes.</p>
<h3>Expected Log Patterns vs Actual:</h3>
<p><strong>MEM-003 (Supersession):</strong></p>
<ul>
<li>Expected: <code>[SUPERSESSION-DIAG] ‚úÖ PATTERN MATCH FOUND: user_salary</code></li>
<li>Actual (from current logs): <code>[SUPERSESSION] Model returned null</code></li>
<li>Root Cause Hypothesis: Pattern matching function not being called, OR patterns not matching the actual content format</li>
</ul>
<p><strong>UX-046 (Memory Visibility):</strong></p>
<ul>
<li>Expected: <code>[VISIBILITY-DIAG] ‚úÖ TRIGGERING MEMORY VISIBILITY HANDLER</code></li>
<li>Actual: Returns prose summary</li>
<li>Root Cause Hypothesis: The test query doesn't match any patterns, OR the early return is being bypassed</li>
</ul>
<p><strong>MEM-007 (Importance):</strong></p>
<ul>
<li>Expected: <code>[IMPORTANCE-DIAG] ‚úÖ CRITICAL keyword found: "allergy"</code></li>
<li>Actual (from current logs): <code>Importance score: 0.50</code></li>
<li>Root Cause Hypothesis: Content doesn't contain keyword (maybe it's "allergic" not "allergy"), OR function not being called</li>
</ul>
<hr>
<h2>üîß PHASE 3: FIXES (Based on Diagnostic Results)</h2>
<h3>3.1 Fix MEM-003: Supersession Pattern Matching</h3>
<p><strong>Problem:</strong> Patterns added but not being checked before model call.</p>
<p><strong>File:</strong> <code>api/services/supersession.js</code></p>
<p>Find the <code>detectFingerprint</code> function and ensure pattern matching runs FIRST:</p>
<pre><code class="language-javascript">export async function detectFingerprint(content) {
  // STEP 1: ALWAYS try pattern matching first (fast, reliable)
  const patternResult = matchPatterns(content);
  if (patternResult) {
    console.log(`[SUPERSESSION] ‚úÖ Pattern match: ${patternResult.fingerprint}`);
    return patternResult;
  }
  
  // STEP 2: Only if patterns fail, try model (slow, unreliable)
  console.log('[SUPERSESSION] No pattern match, trying model...');
  const modelResult = await tryModelFingerprint(content);
  
  // STEP 3: Return model result or null
  return modelResult;
}

function matchPatterns(content) {
  const contentLower = content.toLowerCase();
  
  for (const patternDef of FINGERPRINT_PATTERNS) {
    for (const pattern of patternDef.patterns) {
      if (pattern.test(content) || pattern.test(contentLower)) {
        return {
          fingerprint: patternDef.fingerprint,
          confidence: patternDef.confidence,
          method: 'pattern'
        };
      }
    }
  }
  return null;
}
</code></pre>
<p><strong>CRITICAL:</strong> Verify the patterns in FINGERPRINT_PATTERNS include:</p>
<pre><code class="language-javascript">{
  fingerprint: 'user_salary',
  patterns: [
    /salary\s+(?:is|was|:)?\s*\$?[\d,]+/i,
    /(?:i|my)\s+(?:make|earn|get\s+paid)\s+\$?[\d,]+/i,
    /\$[\d,]+(?:\s+(?:per\s+year|annually|a\s+year|salary))/i,
    /income\s+(?:is|of|:)?\s*\$?[\d,]+/i
  ],
  confidence: 0.95
}
</code></pre>
<h3>3.2 Fix MEM-007: Importance Scoring Keywords</h3>
<p><strong>Problem:</strong> "allergic" not in keyword list, OR scoring not applied to retrieval.</p>
<p><strong>File:</strong> <code>api/memory/intelligent-storage.js</code></p>
<p>Ensure CRITICAL_KEYWORDS includes all variations:</p>
<pre><code class="language-javascript">const CRITICAL_KEYWORDS = [
  // Allergy variations (MUST CATCH ALL)
  'allergy', 'allergies', 'allergic', 'allergen', 'allergens',
  'anaphylactic', 'anaphylaxis', 'epipen', 'epinephrine',
  
  // Medical conditions
  'medical', 'medication', 'medications', 'medicine', 'medicines',
  'prescription', 'prescriptions', 'diagnosed', 'diagnosis',
  'condition', 'conditions', 'disease', 'diseases',
  'diabetic', 'diabetes', 'insulin',
  'asthma', 'asthmatic', 'inhaler',
  'epilepsy', 'epileptic', 'seizure', 'seizures',
  
  // Emergency info
  'emergency', 'emergency contact', 'blood type',
  'surgery', 'surgical', 'operation',
  'pregnant', 'pregnancy',
  'disability', 'disabled',
  'pacemaker', 'implant',
  
  // Safety-critical
  'deadly', 'fatal', 'life-threatening', 'severe reaction'
];
</code></pre>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code></p>
<p>Ensure ORDER BY uses relevance_score:</p>
<pre><code class="language-javascript">const query = `
  SELECT id, content, category_name, relevance_score, mode, created_at
  FROM persistent_memories
  WHERE user_id = $1 
    AND (is_current = true OR is_current IS NULL)
    ${modeFilter}
  ORDER BY relevance_score DESC, created_at DESC
  LIMIT $2
`;
</code></pre>
<h3>3.3 Fix INJ-008: Mode-Aware Retrieval</h3>
<p><strong>Problem:</strong> Mode not being passed through the call chain.</p>
<p><strong>Trace the call chain:</strong></p>
<ol>
<li><code>server.js</code> receives request with mode</li>
<li><code>orchestrator.js</code> calls semantic retrieval</li>
<li><code>semantic-retrieval.js</code> builds query</li>
</ol>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code></p>
<p>Ensure mode is passed to retrieval:</p>
<pre><code class="language-javascript">// Find where semantic retrieval is called
const memories = await this.semanticRetrieval.retrieve({
  userId: userId,
  query: message,
  mode: this.currentMode,  // MUST BE PASSED
  limit: 10
});
</code></pre>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code></p>
<p>Ensure mode is used in query:</p>
<pre><code class="language-javascript">async retrieve(options) {
  const { userId, query, mode, limit } = options;
  
  console.log('[SEMANTIC-RETRIEVAL] Mode received:', mode);
  
  // Build WHERE clause
  let whereClause = 'WHERE user_id = $1 AND (is_current = true OR is_current IS NULL)';
  const params = [userId];
  
  // Add mode filter
  if (mode &amp;&amp; mode !== 'truth-general') {
    whereClause += ` AND (mode = $${params.length + 1} OR mode = 'truth-general' OR mode IS NULL)`;
    params.push(mode);
    console.log('[SEMANTIC-RETRIEVAL] Added mode filter:', mode);
  }
  
  // ... rest of query
}
</code></pre>
<h3>3.4 Fix MODE-022: Cross-Mode Transfer</h3>
<p><strong>Problem:</strong> No mechanism to transfer context between modes.</p>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code></p>
<p>Add cross-mode detection:</p>
<pre><code class="language-javascript">// Detect mode switch
if (previousMode &amp;&amp; previousMode !== currentMode) {
  console.log(`[ORCHESTRATOR] Mode switch detected: ${previousMode} ‚Üí ${currentMode}`);
  
  // For business-validation, check if user references truth-general context
  if (currentMode === 'business-validation') {
    const referencesPersonalContext = this.detectPersonalContextReference(message);
    if (referencesPersonalContext) {
      console.log('[ORCHESTRATOR] Cross-mode reference detected, enabling transfer');
      retrievalOptions.allowCrossMode = true;
      retrievalOptions.fallbackMode = 'truth-general';
    }
  }
}
</code></pre>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code></p>
<p>Handle cross-mode retrieval:</p>
<pre><code class="language-javascript">async retrieve(options) {
  const { userId, query, mode, allowCrossMode, fallbackMode, limit } = options;
  
  // First, try current mode
  let memories = await this.queryMemories(userId, query, mode, limit);
  
  // If no results and cross-mode allowed, try fallback
  if (memories.length === 0 &amp;&amp; allowCrossMode &amp;&amp; fallbackMode) {
    console.log(`[SEMANTIC-RETRIEVAL] No results in ${mode}, trying ${fallbackMode}`);
    memories = await this.queryMemories(userId, query, fallbackMode, limit);
  }
  
  return memories;
}
</code></pre>
<h3>3.5 Fix UX-044: Cross-Session Continuity</h3>
<p><strong>Problem:</strong> Test may be using different userId values.</p>
<p><strong>File:</strong> <code>server.js</code></p>
<p>Ensure consistent userId extraction:</p>
<pre><code class="language-javascript">app.post('/api/chat', async (req, res) =&gt; {
  // CONSISTENT userId extraction - check all sources
  const userId = req.headers['x-user-id'] 
    || req.body?.userId 
    || req.query?.userId 
    || 'anonymous';
  
  console.log('[CHAT] userId extracted:', userId);
  console.log('[CHAT] From header:', req.headers['x-user-id']);
  console.log('[CHAT] From body:', req.body?.userId);
  console.log('[CHAT] From query:', req.query?.userId);
  
  // ... rest of handler
});
</code></pre>
<p><strong>CRITICAL:</strong> Check if the TEST is sending the same userId in both sessions. If the test sends different userIds, that's a test bug, not a system bug.</p>
<h3>3.6 Fix UX-046: Memory Visibility</h3>
<p><strong>Problem:</strong> Pattern not matching OR early return not happening.</p>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code></p>
<p>The detection code was added at line 475, but verify it runs BEFORE any other processing:</p>
<pre><code class="language-javascript">async processRequest(message, options = {}) {
  // ... initial setup ...
  
  // STEP 0.4: MEMORY VISIBILITY - MUST BE EARLY
  const memoryVisibilityPatterns = [
    /what do you (?:remember|know) about me/i,
    /show (?:me )?(?:my )?memor(?:y|ies)/i,
    /list (?:my |what you )?(?:remember|stored|know)/i,
    /what (?:have you |do you have )(?:stored|saved|remembered)/i,
    /my (?:stored )?(?:memories|information|data)/i,
    // ADD MORE PATTERNS to catch variations
    /what.*you.*remember/i,
    /show.*what.*know/i,
    /see.*my.*memories/i,
    /view.*stored.*about/i
  ];
  
  const isMemoryVisibilityRequest = memoryVisibilityPatterns.some(p =&gt; p.test(message));
  
  if (isMemoryVisibilityRequest) {
    console.log('[MEMORY-VISIBILITY] ‚úÖ Detected - returning structured list');
    
    // Direct database query - bypass all AI processing
    const memories = await this.pool.query(`
      SELECT id, content, category_name, created_at, relevance_score, mode
      FROM persistent_memories
      WHERE user_id = $1 AND (is_current = true OR is_current IS NULL)
      ORDER BY relevance_score DESC, created_at DESC
      LIMIT 20
    `, [userId]);
    
    if (memories.rows.length === 0) {
      return {
        success: true,
        response: "I don't have any memories stored for you yet.",
        metadata: { memoryVisibility: true, count: 0 }
      };
    }
    
    // Format as STRUCTURED LIST (not prose!)
    let response = `I have ${memories.rows.length} memories stored:\n\n`;
    memories.rows.forEach((m, i) =&gt; {
      const importance = m.relevance_score &gt;= 0.9 ? '‚≠ê Critical' : 
                        m.relevance_score &gt;= 0.75 ? 'üìå Important' : 'üìù Note';
      response += `${i + 1}. [${m.category_name}] ${m.content}\n`;
      response += `   ${importance} | ${new Date(m.created_at).toLocaleDateString()}\n\n`;
    });
    
    // RETURN EARLY - do not continue to AI processing
    return {
      success: true,
      response: response.trim(),
      metadata: { memoryVisibility: true, count: memories.rows.length }
    };
  }
  
  // ... rest of normal processing ...
}
</code></pre>
<h3>3.7 Fix UX-049: User Priorities Learning</h3>
<p><strong>Problem:</strong> System not tracking/learning priorities.</p>
<p>This requires:</p>
<ol>
<li>Detecting when user expresses priorities</li>
<li>Storing priority facts with high importance</li>
<li>Retrieving and applying priorities</li>
</ol>
<p><strong>File:</strong> <code>api/memory/intelligent-storage.js</code></p>
<p>Add priority detection:</p>
<pre><code class="language-javascript">const PRIORITY_PATTERNS = [
  /(?:i |my )(?:priority|priorities|most important|care most about)/i,
  /(?:always|never) (?:want|need|prefer)/i,
  /(?:this is|that's) (?:important|critical|essential)/i,
  /(?:don't|do not) ever/i,
  /(?:make sure|ensure|remember that)/i
];

function detectUserPriority(content) {
  for (const pattern of PRIORITY_PATTERNS) {
    if (pattern.test(content)) {
      return true;
    }
  }
  return false;
}

// In storeWithIntelligence:
if (detectUserPriority(content)) {
  console.log('[INTELLIGENT-STORAGE] User priority detected - boosting importance');
  importanceScore = Math.max(importanceScore, 0.85);
}
</code></pre>
<hr>
<h2>‚úÖ PHASE 4: VERIFICATION CHECKLIST</h2>
<p>After implementing fixes, ALL of these must pass:</p>
<h3>Supersession (MEM-003)</h3>
<ul>
<li>[ ] Log shows: <code>[SUPERSESSION-DIAG] ‚úÖ PATTERN MATCH FOUND: user_salary</code></li>
<li>[ ] Store "My salary is $80,000" ‚Üí fingerprint detected</li>
<li>[ ] Store "My salary is $95,000" ‚Üí fingerprint detected, old marked superseded</li>
<li>[ ] Query "What's my salary?" ‚Üí returns "$95,000" ONLY</li>
</ul>
<h3>Importance Scoring (MEM-007)</h3>
<ul>
<li>[ ] Log shows: <code>[IMPORTANCE-DIAG] ‚úÖ CRITICAL keyword found: "allergic"</code></li>
<li>[ ] Store "I'm allergic to peanuts" ‚Üí importance = 0.95</li>
<li>[ ] Store "I like pizza" ‚Üí importance = 0.50</li>
<li>[ ] Query "What should you know about feeding me?" ‚Üí allergy BEFORE preference</li>
</ul>
<h3>Mode-Aware Retrieval (INJ-008)</h3>
<ul>
<li>[ ] Log shows: <code>[MODE-DIAG] Adding mode filter for: business-validation</code></li>
<li>[ ] Store in business-validation mode</li>
<li>[ ] Query in same mode ‚Üí retrieves memory</li>
<li>[ ] Query in different mode ‚Üí does NOT retrieve (unless cross-mode enabled)</li>
</ul>
<h3>Cross-Mode Transfer (MODE-022)</h3>
<ul>
<li>[ ] Log shows: <code>[CROSS-MODE-DIAG] ‚úÖ Cross-mode transfer ENABLED</code></li>
<li>[ ] Store info in truth-general</li>
<li>[ ] Switch to business-validation</li>
<li>[ ] Reference personal context ‚Üí retrieves from truth-general</li>
</ul>
<h3>Cross-Session (UX-044)</h3>
<ul>
<li>[ ] Log shows same userId in both sessions</li>
<li>[ ] Session A: Store fact</li>
<li>[ ] Session B: Query fact ‚Üí retrieved</li>
</ul>
<h3>Memory Visibility (UX-046)</h3>
<ul>
<li>[ ] Log shows: <code>[VISIBILITY-DIAG] ‚úÖ TRIGGERING MEMORY VISIBILITY HANDLER</code></li>
<li>[ ] Query "What do you remember about me?"</li>
<li>[ ] Response is NUMBERED LIST, not prose</li>
<li>[ ] Shows category, content, importance, date</li>
</ul>
<h3>User Priorities (UX-049)</h3>
<ul>
<li>[ ] Store "Understanding AI is very important to me"</li>
<li>[ ] Priority detected and stored with high importance</li>
<li>[ ] Future queries reflect this priority</li>
</ul>
<hr>
<h2>üö´ DO NOT</h2>
<ol>
<li><strong>DO NOT</strong> skip diagnostic logging - we need to see what's happening</li>
<li><strong>DO NOT</strong> assume patterns match - log and verify</li>
<li><strong>DO NOT</strong> change working tests (greetings, TRUTH-018 are fixed)</li>
<li><strong>DO NOT</strong> add new features - only fix broken ones</li>
<li><strong>DO NOT</strong> merge without ALL verification checks passing</li>
<li><strong>DO NOT</strong> remove any diagnostic logging until all tests pass</li>
</ol>
<hr>
<h2>üìã IMPLEMENTATION ORDER</h2>
<ol>
<li><strong>Deploy diagnostic logging FIRST</strong> - get visibility into what's happening</li>
<li><strong>Analyze logs</strong> - identify exact failure points</li>
<li><strong>Fix supersession</strong> (MEM-003) - pattern matching</li>
<li><strong>Fix importance scoring</strong> (MEM-007) - keyword matching</li>
<li><strong>Fix mode-aware retrieval</strong> (INJ-008) - mode passing</li>
<li><strong>Fix memory visibility</strong> (UX-046) - pattern matching + early return</li>
<li><strong>Fix cross-mode</strong> (MODE-022) - fallback logic</li>
<li><strong>Fix cross-session</strong> (UX-044) - userId consistency</li>
<li><strong>Fix user priorities</strong> (UX-049) - priority detection</li>
<li><strong>Run full test suite</strong> - verify 100% pass</li>
</ol>
<hr>
<h2>üîó CALL CHAIN DOCUMENTATION</h2>
<p>For each failing test, trace the COMPLETE call chain:</p>
<h3>MEM-003 Call Chain:</h3>
<pre><code>User sends "My salary is $95,000"
‚Üí server.js receives POST /api/chat
‚Üí orchestrator.processRequest() called
‚Üí [After AI response] intelligent-storage.storeWithIntelligence() called
‚Üí supersession.detectFingerprint() should detect salary
‚Üí IF fingerprint found: mark old salary memories is_current=false
‚Üí Store new memory with fingerprint
‚Üí Query "What's my salary?"
‚Üí semantic-retrieval filters is_current=true
‚Üí Returns ONLY newest salary
</code></pre>
<h3>UX-046 Call Chain:</h3>
<pre><code>User sends "What do you remember about me?"
‚Üí server.js receives POST /api/chat
‚Üí orchestrator.processRequest() called
‚Üí EARLY: memoryVisibilityPatterns.some() should match
‚Üí IF match: direct database query
‚Üí Format as numbered list
‚Üí RETURN EARLY (skip all AI processing)
‚Üí User sees structured list
</code></pre>
<h3>MEM-007 Call Chain:</h3>
<pre><code>User sends "I'm allergic to peanuts"
‚Üí server.js receives POST /api/chat
‚Üí orchestrator.processRequest()
‚Üí intelligent-storage.storeWithIntelligence()
‚Üí calculateImportanceScore() should detect "allergic"
‚Üí Return 0.95 importance
‚Üí Store with relevance_score = 0.95
‚Üí Query "What should you know about feeding me?"
‚Üí semantic-retrieval ORDER BY relevance_score DESC
‚Üí Allergy (0.95) returned BEFORE preferences (0.50)
</code></pre>
<hr>
<h2>üìä SUCCESS CRITERIA</h2>
<p>This issue is COMPLETE when:</p>
<ol>
<li>‚úÖ All 7 failing tests pass</li>
<li>‚úÖ Diagnostic logs show expected behavior at each step</li>
<li>‚úÖ No regression in previously passing tests</li>
<li>‚úÖ Pass rate = 100% (or 60/61 with INFRA-041 skipped)</li>
<li>‚úÖ All changes aligned with Bible doctrines</li>
</ol>
<hr>
<p><strong>Priority:</strong> üî¥ CRITICAL
<strong>Estimated Effort:</strong> 6-8 hours with proper diagnostics
<strong>Risk Level:</strong> MEDIUM (extensive logging helps reduce risk)</p></body></html><!--EndFragment-->
</body>
</html>
Your task is to:
1. Analyze the issue carefully to understand the problem
2. Look through the repository to identify the relevant files that need to be modified
3. Make precise changes to fix the issue
4. Use the Edit tool to modify files directly when needed
5. Be minimal in your changes - only modify what's necessary to fix the issue

After making changes, provide a summary of what you did in this format:

---SUMMARY---
[Your detailed summary of changes, including which files were modified and how]
---END SUMMARY---

Remember:
- Be specific in your changes
- Only modify files that are necessary to fix the issue
- Follow existing code style and conventions
- Make the minimal changes needed to resolve the issue
