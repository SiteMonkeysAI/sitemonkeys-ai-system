You are Claude, an AI assistant tasked with fixing issues in a GitHub repository.

Issue #648: [claude-fix] Storage Integrity Contract — SMDEEP 15/15

Issue Description:
<html>
<body>
<!--StartFragment--><html><head></head><body><h1>[claude-fix] Storage Integrity Contract — SMDEEP 15/15</h1>
<h2>The Bible Principle</h2>
<blockquote>
<p>"The system may reason beyond available facts, but it may never pretend that reasoning is fact."</p>
</blockquote>
<blockquote>
<p>"Claiming ignorance of stored information constitutes a <strong>catastrophic trust violation</strong>."</p>
</blockquote>
<p>This issue addresses a fundamental gap: <strong>we have no contract guaranteeing that user-provided information survives storage</strong>. The system can't claim ignorance of what was never stored in the first place.</p>
<hr>
<h2>Current State</h2>

Suite | Score | Status
-- | -- | --
SMFULL | 24/24 | ✅ Perfect
SMDEEP | 11/15 | 4 failures — all storage-related


<p><strong>The validators are NOT the problem. Storage is.</strong></p>
<hr>
<h2>The Storage Contract (What MUST Be True)</h2>
<p>When a user provides personal information, that information MUST be retrievable later. This is non-negotiable for a truth-first system.</p>
<h3>Contract Requirements:</h3>
<ol>
<li><strong>Extraction Fidelity</strong> — Critical anchors (names, vehicles, dates, prices) must survive compression</li>
<li><strong>Descriptor Preservation</strong> — "friend Alex" and "colleague Alex" must remain distinguishable</li>
<li><strong>Unicode Integrity</strong> — International names (Björn, José, Zhang Wei) must be preserved exactly</li>
<li><strong>Anchor Storage</strong> — Temporal and pricing anchors must reach the database metadata</li>
</ol>
<hr>
<h2>Investigation Scope</h2>
<p>You have full authority to investigate the entire storage pipeline. The likely files are:</p>
<ul>
<li><code>api/memory/intelligent-storage.js</code> — Main storage logic
<ul>
<li><code>storeWithIntelligence()</code> — Entry point</li>
<li><code>extractKeyFacts()</code> — Compression (where data might be lost)</li>
<li><code>extractTemporalAnchors()</code> — Temporal extraction</li>
<li><code>extractUnicodeNames()</code> — Unicode extraction</li>
<li><code>getDescriptorSignature()</code> — Descriptor detection for dedup</li>
<li>Deduplication logic (~line 1600+)</li>
</ul>
</li>
<li><code>server.js</code> — How storage is called</li>
<li><code>api/core/orchestrator.js</code> — Validators (for reference, but NOT the problem)</li>
</ul>
<p>But do not limit yourself to these files. Follow the data flow wherever it leads.</p>
<hr>
<h2>Required Diagnostic Logging</h2>
<p>Before making fixes, add logging to understand the actual flow:</p>
<pre><code class="language-javascript">// At storage entry point
console.log(`[STORAGE-CONTRACT] input_length=${userMessage.length} first_100_chars="${userMessage.substring(0,100)}"`);

// After fact extraction
console.log(`[STORAGE-CONTRACT] extracted_facts_length=${facts.length} first_100_chars="${facts.substring(0,100)}"`);

// In extractUnicodeNames
console.log(`[STORAGE-CONTRACT] unicode_input="${content.substring(0,100)}" pattern_matches=${JSON.stringify(matches)}`);

// In getDescriptorSignature  
console.log(`[STORAGE-CONTRACT] descriptor_content="${content.substring(0,50)}" detected="${descriptor}"`);

// In dedup decision
console.log(`[STORAGE-CONTRACT] dedup_decision existing_id=${existingId} existing_desc="${existingDesc}" new_desc="${newDesc}" action=${action}`);

// After storage completes
console.log(`[STORAGE-CONTRACT] stored_id=${newId} category=${category} metadata_keys=${Object.keys(metadata||{}).join(',')}`);
</code></pre>
<p>This logging will reveal exactly where data is lost.</p>
<hr>
<h2>Specific Failure Analysis</h2>
<h3>NUA1: Two Alexes Must Stay Separate</h3>
<p><strong>Test scenario:</strong> User says "My friend Alex loves hiking" then "My colleague Alex works in marketing"</p>
<p><strong>Expected:</strong> 2 separate memories with descriptors "friend" and "colleague"</p>
<p><strong>Actual:</strong> <code>db_rows=1</code> — only one Alex exists</p>
<p><strong>Investigation questions:</strong></p>
<ul>
<li>Is <code>getDescriptorSignature()</code> being called for both messages?</li>
<li>What descriptor does it extract from "My friend Alex..."?</li>
<li>What descriptor does it extract from "My colleague Alex..."?</li>
<li>Is the dedup logic comparing descriptors?</li>
<li>Is the second message being stored at all, or rejected as duplicate?</li>
</ul>
<p><strong>Possible fixes:</strong></p>
<ul>
<li>Descriptor pattern might not match "friend" or "colleague"</li>
<li>Dedup might be comparing content similarity, not descriptor</li>
<li>Second message might be classified as "no new information"</li>
</ul>
<hr>
<h3>STR1: Vehicle Must Be Stored</h3>
<p><strong>Test scenario:</strong> User provides 10 facts including vehicle information</p>
<p><strong>Expected:</strong> Vehicle info retrievable from database</p>
<p><strong>Actual:</strong> <code>reason=not_in_memory</code></p>
<p><strong>Investigation questions:</strong></p>
<ul>
<li>Does the message containing vehicle info reach <code>storeWithIntelligence()</code>?</li>
<li>Does <code>extractKeyFacts()</code> preserve vehicle info, or compress it away?</li>
<li>Is vehicle info being categorized correctly?</li>
<li>Is the memory being stored with vehicle-related content?</li>
</ul>
<p><strong>Possible fixes:</strong></p>
<ul>
<li>Compression might be dropping "less important" facts</li>
<li>Vehicle might be categorized into a non-queried category</li>
<li>Multiple facts in one message might only store the first N</li>
</ul>
<hr>
<h3>CMP2: Unicode Names Must Be Preserved</h3>
<p><strong>Test scenario:</strong> "My contacts are Zhang Wei, Björn, and José García"</p>
<p><strong>Expected:</strong> <code>metadata.anchors.unicode</code> contains ["Zhang Wei", "Björn", "José García"]</p>
<p><strong>Actual:</strong> <code>names_found=[]</code></p>
<p><strong>Investigation questions:</strong></p>
<ul>
<li>What does <code>extractUnicodeNames()</code> receive as input?</li>
<li>What pattern is it using to match?</li>
<li>Does the pattern match single names like "Björn"?</li>
<li>Does the pattern match names without diacritics but with unicode context like "Zhang Wei"?</li>
</ul>
<p><strong>Known issue:</strong> Current pattern requires multi-word capitalized names. Single names like "Björn" won't match.</p>
<p><strong>Fix approach:</strong></p>
<pre><code class="language-javascript">extractUnicodeNames(content) {
  if (!content || typeof content !== 'string') return [];
  const safeContent = content.substring(0, 500);
  
  // Pattern 1: Multi-word names like "José García-López"
  const multiWordPattern = /(?:[A-Z][a-zÀ-ÿ]+[-\s]?)+[A-ZÀ-ÿ][a-zÀ-ÿ]+/g;
  
  // Pattern 2: Single words with diacritics like "Björn", "José"  
  const singleWordPattern = /\b[A-Z][a-zÀ-ÿ]*[À-ÿ][a-zÀ-ÿ]*\b/g;
  
  // Pattern 3: CJK-adjacent names (capitalized words near unicode)
  // This catches "Zhang Wei" by context
  
  const multiMatches = safeContent.match(multiWordPattern) || [];
  const singleMatches = safeContent.match(singleWordPattern) || [];
  
  const allMatches = [...new Set([...multiMatches, ...singleMatches])];
  return allMatches
    .map(m =&gt; m.replace(/[.,;:!?'")\]}&gt;]+$/, '').trim())
    .filter(m =&gt; m.length &gt; 0);
}
</code></pre>
<hr>
<h3>EDG3: Pricing Anchors Must Survive Compression</h3>
<p><strong>Test scenario:</strong> Long business input containing "$50/month" pricing</p>
<p><strong>Expected:</strong> Pricing preserved in anchors or response</p>
<p><strong>Actual:</strong> <code>preservedPricing=false</code></p>
<p><strong>Investigation questions:</strong></p>
<ul>
<li>Is there a <code>extractPricingAnchors()</code> function? If not, should there be?</li>
<li>Does compression prompt mention preserving pricing/financial data?</li>
<li>Is pricing being stored in metadata but not retrieved?</li>
</ul>
<p><strong>Possible fixes:</strong></p>
<ul>
<li>Add pricing anchor extraction similar to temporal anchors</li>
<li>Modify compression prompt to explicitly preserve financial figures</li>
<li>Add pricing to the "critical anchors" list that must survive compression</li>
</ul>
<hr>
<h2>Success Criteria</h2>
<p>After this fix:</p>
<ul>
<li>SMDEEP: 15/15 (up from 11/15)</li>
<li>SMFULL: 24/24 (maintained)</li>
<li>Storage logs show data flowing correctly through entire pipeline</li>
<li>Each user-provided fact is verifiably retrievable</li>
</ul>
<hr>
<h2>What NOT To Do</h2>
<ul>
<li>❌ Don't modify validators — they work correctly</li>
<li>❌ Don't add MORE validators — storage is the bottleneck</li>
<li>❌ Don't guess at fixes — use logging to find actual root cause</li>
<li>❌ Don't make partial fixes — if NUA1 is broken because dedup is wrong, fix dedup completely</li>
<li>❌ Don't introduce new failure points — every change must be tested against full suite</li>
</ul>
<hr>
<h2>The Caring Family Member Test</h2>
<p>Before completing this fix, ask:</p>
<blockquote>
<p>"If a user told their caring family member these facts, would that family member remember them correctly?"</p>
</blockquote>
<p>If the system is dropping "friend Alex" vs "colleague Alex" distinction, it's not acting like a caring family member. It's acting like a forgetful acquaintance.</p>
<p>The Bible says the system should be like a family member with CEO-level expertise. A CEO remembers who introduced whom, distinguishes between contacts, and never forgets critical business details like pricing.</p>
<p><strong>Fix the storage pipeline so it remembers like a caring family member would.</strong></p>
<hr>
<h2>Verification</h2>
<p>After fix is deployed, run SMFULL + SMDEEP and search logs for:</p>
<pre><code>[STORAGE-CONTRACT]
[AMBIGUITY-AUTHORITATIVE] entity=Alex db_rows=2
[VEHICLE-AUTHORITATIVE] vehicle_found=true
[UNICODE-AUTHORITATIVE] names_found=["Björn","José García"]
</code></pre>
<p>The fix is complete when all 4 failing tests show successful storage AND retrieval.</p></body></html><!--EndFragment-->
</body>
</html>
Your task is to:
1. Analyze the issue carefully to understand the problem
2. Look through the repository to identify the relevant files that need to be modified
3. Make precise changes to fix the issue
4. Use the Edit tool to modify files directly when needed
5. Be minimal in your changes - only modify what's necessary to fix the issue

After making changes, provide a summary of what you did in this format:

---SUMMARY---
[Your detailed summary of changes, including which files were modified and how]
---END SUMMARY---

Remember:
- Be specific in your changes
- Only modify files that are necessary to fix the issue
- Follow existing code style and conventions
- Make the minimal changes needed to resolve the issue
