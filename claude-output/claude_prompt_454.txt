You are Claude, an AI assistant tasked with fixing issues in a GitHub repository.

Issue #454: [claude-fix] Issue #452: CRITICAL - Complete Fix for Remaining Test Failures (Trace-Verified)

Issue Description:
<html>
<body>
<!--StartFragment--><html><head></head><body><h1>Issue #452: CRITICAL - Complete Fix for Remaining Test Failures (Trace-Verified)</h1>
<h2>üö® SEVERITY: CRITICAL - BLOCKING RELEASE</h2>
<p>The previous PR #451 deployed but the fixes are NOT working. This issue requires <strong>complete trace verification</strong> - every code path must be followed start-to-finish to ensure fixes actually execute.</p>
<hr>
<h2>üìú BIBLE ALIGNMENT REQUIREMENTS</h2>
<p>Every fix MUST align with these non-negotiable doctrines:</p>
<p><strong>Innovation #3 - Age + Relevance Weighted Overwrite:</strong></p>
<blockquote>
<p>"When new information needs storage space, system identifies lowest-scoring memories - those that are both old AND rarely accessed. These are overwritten first."</p>
</blockquote>
<p><strong>Innovation #7 - Memory Importance Scoring:</strong></p>
<blockquote>
<p>"Every memory entry has associated importance score... Score increases when information is mentioned multiple times, retrieved frequently, referenced in multiple contexts, or emphasized by user."</p>
</blockquote>
<p><strong>Anti-Engagement Architecture:</strong></p>
<blockquote>
<p>"Shorter conversations = success. Messages to resolution: 1-2. Never drip-feed information."</p>
</blockquote>
<p><strong>Caring Family Member Principle:</strong></p>
<blockquote>
<p>"A fiercely loving, brutally honest family member who has world-class expertise."</p>
</blockquote>
<hr>
<h2>üî¥ FAILING TESTS (8 Total)</h2>

Test | Current Behavior | Required Behavior | Root Cause
-- | -- | -- | --
MEM-003 | Returns old salary ($80K) | Must return new salary ($95K) | Supersession fingerprint returns null
MEM-007 | Returns food preference, ignores allergy | Must return allergy FIRST | Importance score not applied to retrieval ranking
INJ-008 | Mode-specific memory not found | Must retrieve mode-specific memories | Mode filter not matching stored mode
TRUTH-018 | Returns old meeting time | Must return updated time | Same as MEM-003 - supersession failing
UX-044 | Cross-session memory fails | Must persist across sessions | Unknown - needs trace
UX-046 | Prose summary instead of list | Must show structured memory list | Natural language handler not triggering
RESP-GREET "Hello" | 270 chars | Must be < 150 chars | Sentence boundary overrides hard limit
RESP-GREET "Hey" | 309 chars | Must be < 150 chars | Same as above


<hr>
<h2>üîß FIX 1: GREETING LENGTH ENFORCEMENT</h2>
<h3>Problem Trace</h3>
<pre><code>Log shows:
[ORCHESTRATOR] ‚úÇÔ∏è Response too long for simple_short (793 &gt; 150)
[ORCHESTRATOR] ‚úÇÔ∏è Simple short query truncated: 793 ‚Üí 309 chars
</code></pre>
<p>The code detects the response is over 150, but the truncation results in 309 chars. The sentence boundary logic is overriding the hard limit.</p>
<h3>Required Fix Location</h3>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code>
<strong>Function:</strong> Phase 7.5 Response Intelligence (around lines 1159-1190)</p>
<h3>Current Code Analysis</h3>
<p>Find the exact code block that handles <code>simple_short</code> truncation. The issue is:</p>
<ol>
<li>Code finds last sentence boundary</li>
<li>If sentence boundary is at position 309, it uses that</li>
<li>There's no final enforcement of the 150 char maximum</li>
</ol>
<h3>EXACT Fix Required</h3>
<pre><code class="language-javascript">// Phase 7.5: Response Intelligence - HARD LIMIT for simple_short/greetings
if (classification.classification === 'simple_short' || classification.classification === 'greeting') {
  const HARD_LIMIT = 150;
  
  if (personalityResponse.response.length &gt; HARD_LIMIT) {
    let truncated = personalityResponse.response.substring(0, HARD_LIMIT);
    
    // Try to find a clean sentence break, but ONLY within the limit
    const lastPeriod = truncated.lastIndexOf('.');
    const lastQuestion = truncated.lastIndexOf('?');
    const lastExclaim = truncated.lastIndexOf('!');
    const lastSentence = Math.max(lastPeriod, lastQuestion, lastExclaim);
    
    // Only use sentence boundary if it's at least 50 chars in (not too short)
    if (lastSentence &gt; 50) {
      personalityResponse.response = personalityResponse.response.substring(0, lastSentence + 1);
    } else {
      // No good sentence break - hard cut with ellipsis
      personalityResponse.response = truncated.substring(0, HARD_LIMIT - 3).trim() + '...';
    }
    
    // CRITICAL: Final safety check - NEVER exceed HARD_LIMIT
    if (personalityResponse.response.length &gt; HARD_LIMIT) {
      personalityResponse.response = personalityResponse.response.substring(0, HARD_LIMIT - 3).trim() + '...';
    }
    
    responseIntelligence.applied = true;
    responseIntelligence.finalLength = personalityResponse.response.length;
    responseIntelligence.reason = `hard_limited_to_${HARD_LIMIT}_chars`;
    this.log(`‚úÇÔ∏è Greeting HARD LIMITED: ${responseIntelligence.originalLength} ‚Üí ${responseIntelligence.finalLength} chars`);
  }
}
</code></pre>
<h3>Verification Trace Required</h3>
<ol>
<li>Find ALL places where <code>simple_short</code> or <code>greeting</code> classification affects response length</li>
<li>Ensure NO other code path can override this truncation AFTER it's applied</li>
<li>Verify the log message <code>hard_limited_to_150_chars</code> appears in production logs</li>
<li>Test: <code>"Hello"</code> must return response &lt; 150 chars</li>
<li>Test: <code>"Hey"</code> must return response &lt; 150 chars</li>
</ol>
<hr>
<h2>üîß FIX 2: SUPERSESSION (MEM-003, TRUTH-018)</h2>
<h3>Problem Trace</h3>
<pre><code>Log shows:
[SUPERSESSION] Model returned null (475ms)
[INTELLIGENT-STORAGE] Fingerprint result: none (confidence: 0, method: model)
</code></pre>
<p>The model-based fingerprint detection is returning null for facts like "salary is $95,000". Without a fingerprint, supersession never happens.</p>
<h3>Required Fix Location</h3>
<p><strong>File:</strong> <code>api/services/supersession.js</code>
<strong>Function:</strong> <code>generateFactFingerprint()</code> or equivalent</p>
<h3>Root Cause Analysis</h3>
<p>The fingerprint generator relies on an AI model call that's returning null. This means:</p>
<ol>
<li>Either the model isn't recognizing simple facts</li>
<li>Or the response parsing is failing</li>
<li>Or there's no fallback when the model fails</li>
</ol>
<h3>EXACT Fix Required</h3>
<p>Add pattern-based fallback that ALWAYS works for common fact types:</p>
<pre><code class="language-javascript">/**
 * Generate fact fingerprint with pattern-based fallback
 * Bible: Innovation #3 - newer facts MUST supersede older facts
 */
export function generateFactFingerprint(content) {
  // PATTERN-BASED DETECTION (runs FIRST, doesn't depend on model)
  const patterns = {
    salary: /(?:salary|income|pay|compensation|earning)[^\d]*(\$?[\d,]+(?:\.\d{2})?)/i,
    age: /(?:i am|i'm|my age is|years old)[^\d]*(\d{1,3})/i,
    job_title: /(?:i work as|my job is|i am a|my title is|my role is)\s+(?:a |an )?([^,.]+)/i,
    employer: /(?:i work at|i work for|employed at|employed by|my company is)\s+([^,.]+)/i,
    location: /(?:i live in|i'm in|i am in|my home is|i reside in)\s+([^,.]+)/i,
    meeting_time: /(?:meeting|appointment|call)[^\d]*(?:at |is |scheduled for )?(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)/i,
    email: /(?:my email is|email:|email address)\s*([^\s,]+@[^\s,]+)/i,
    phone: /(?:my (?:phone|number|cell) is|phone:|call me at)\s*([\d\-\(\)\s]+)/i,
  };
  
  for (const [factType, pattern] of Object.entries(patterns)) {
    const match = content.match(pattern);
    if (match) {
      // Create deterministic fingerprint from fact type + normalized value
      const normalizedValue = match[1].toLowerCase().replace(/[^a-z0-9]/g, '');
      const fingerprint = `${factType}:${normalizedValue.substring(0, 20)}`;
      
      console.log(`[SUPERSESSION] Pattern match: ${factType} = "${match[1]}" ‚Üí fingerprint: ${fingerprint}`);
      
      return {
        fingerprint: fingerprint,
        confidence: 0.9,
        method: 'pattern',
        factType: factType,
        extractedValue: match[1]
      };
    }
  }
  
  // MODEL-BASED FALLBACK (only if patterns don't match)
  // ... existing model-based code ...
  
  // If model also fails, return null (but log it)
  console.log(`[SUPERSESSION] No fingerprint detected for: "${content.substring(0, 50)}..."`);
  return null;
}
</code></pre>
<h3>Verification Trace Required</h3>
<ol>
<li>Find where <code>generateFactFingerprint</code> is called in <code>intelligent-storage.js</code></li>
<li>Verify the fingerprint result is used in <code>storeWithSupersession()</code></li>
<li>Trace how <code>storeWithSupersession</code> marks old memories as <code>is_current = false</code></li>
<li>Verify the retrieval query filters on <code>is_current = true</code></li>
<li>Test: Store "salary is $80,000", then "salary is $95,000", query returns $95,000 ONLY</li>
</ol>
<hr>
<h2>üîß FIX 3: IMPORTANCE SCORING (MEM-007)</h2>
<h3>Problem Trace</h3>
<pre><code>Log shows:
[INTELLIGENT-STORAGE] üìä Importance score: 0.50 (category: personal_life_interests)
</code></pre>
<p>When storing "I'm allergic to peanuts", the importance score is 0.50 instead of 0.95. Either:</p>
<ol>
<li>The keyword detection isn't matching "allergic"</li>
<li>OR the content is being routed to wrong category before scoring</li>
<li>OR the scoring runs but retrieval doesn't use it</li>
</ol>
<h3>Required Fix - Part A: Storage Scoring</h3>
<p><strong>File:</strong> <code>api/memory/intelligent-storage.js</code>
<strong>Function:</strong> <code>calculateImportanceScore()</code> or equivalent</p>
<p>Verify this function exists and matches:</p>
<pre><code class="language-javascript">const CRITICAL_KEYWORDS = [
  'allergy', 'allergic', 'allergies', 'allergen',
  'anaphylactic', 'anaphylaxis', 'epipen',
  'medical', 'medication', 'medicine', 'prescription',
  'emergency', 'emergency contact',
  'condition', 'diagnosis', 'diagnosed',
  'diabetic', 'diabetes', 'insulin',
  'asthma', 'inhaler',
  'blood type', 'blood pressure',
  'surgery', 'surgical', 'operation',
  'pregnant', 'pregnancy',
  'disability', 'disabled',
  'pacemaker', 'implant'
];

const HIGH_PRIORITY_KEYWORDS = [
  'spouse', 'wife', 'husband', 'partner', 'married',
  'child', 'children', 'son', 'daughter', 'kids',
  'parent', 'mother', 'father', 'mom', 'dad',
  'family',
  'work', 'job', 'employer', 'employed', 'career',
  'salary', 'income', 'pay', 'compensation',
  'budget', 'savings', 'debt',
  'address', 'live', 'home', 'house', 'apartment'
];

function calculateImportanceScore(content, category) {
  const contentLower = content.toLowerCase();
  
  // CRITICAL: Health, safety, medical - HIGHEST priority
  for (const keyword of CRITICAL_KEYWORDS) {
    if (contentLower.includes(keyword)) {
      console.log(`[IMPORTANCE] CRITICAL keyword "${keyword}" found ‚Üí 0.95`);
      return 0.95;
    }
  }
  
  // HIGH: Family, work, financial
  for (const keyword of HIGH_PRIORITY_KEYWORDS) {
    if (contentLower.includes(keyword)) {
      console.log(`[IMPORTANCE] HIGH keyword "${keyword}" found ‚Üí 0.80`);
      return 0.80;
    }
  }
  
  // MEDIUM: Health category without specific keywords
  if (category === 'health_wellness' || category === 'health') {
    console.log(`[IMPORTANCE] Health category ‚Üí 0.75`);
    return 0.75;
  }
  
  // DEFAULT
  console.log(`[IMPORTANCE] Default score ‚Üí 0.50`);
  return 0.50;
}
</code></pre>
<h3>Required Fix - Part B: Retrieval Ranking</h3>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code>
<strong>Function:</strong> <code>buildPrefilterQuery()</code> or main retrieval function</p>
<p>Verify the ORDER BY clause prioritizes <code>relevance_score</code>:</p>
<pre><code class="language-sql">ORDER BY relevance_score DESC, created_at DESC
</code></pre>
<p>NOT:</p>
<pre><code class="language-sql">ORDER BY created_at DESC  -- WRONG - ignores importance!
</code></pre>
<h3>Required Fix - Part C: Verify Score Is Stored</h3>
<p>In <code>intelligent-storage.js</code>, find where the INSERT happens and verify:</p>
<pre><code class="language-javascript">const importanceScore = calculateImportanceScore(facts, category);

const result = await this.db.query(`
  INSERT INTO persistent_memories (
    user_id, category_name, subcategory, content, token_count, 
    relevance_score, ...  -- relevance_score MUST be here
  ) VALUES ($1, $2, $3, $4, $5, $6, ...)
`, [userId, category, subcategory, facts, tokenCount, importanceScore, ...]);
</code></pre>
<h3>Verification Trace Required</h3>
<ol>
<li>Store "I'm allergic to peanuts" - log should show <code>CRITICAL keyword "allergic" found ‚Üí 0.95</code></li>
<li>Store "I like pizza" - log should show <code>Default score ‚Üí 0.50</code></li>
<li>Query "What should you know about feeding me?"</li>
<li>Retrieval should return allergy (0.95) BEFORE pizza (0.50)</li>
<li>Verify the <code>relevance_score</code> column in database actually contains 0.95 and 0.50</li>
</ol>
<hr>
<h2>üîß FIX 4: MODE-AWARE RETRIEVAL (INJ-008)</h2>
<h3>Problem Trace</h3>
<pre><code>Test: Set mode to business-validation, store "Q3 revenue was $5M", query returns nothing
Log shows: "I don't have enough information about your company's Q3 performance"
</code></pre>
<h3>Required Fix Location</h3>
<p><strong>File:</strong> <code>api/services/semantic-retrieval.js</code>
<strong>Function:</strong> <code>buildPrefilterQuery()</code> or wherever mode filtering happens</p>
<h3>Root Cause Analysis</h3>
<p>Either:</p>
<ol>
<li>Memory is stored without mode tag</li>
<li>OR retrieval is filtering too strictly on mode</li>
<li>OR mode parameter isn't being passed correctly</li>
</ol>
<h3>Verification Steps</h3>
<p><strong>Step 1:</strong> Verify storage includes mode</p>
<p>In <code>intelligent-storage.js</code>, find the INSERT and verify mode is stored:</p>
<pre><code class="language-javascript">const result = await this.db.query(`
  INSERT INTO persistent_memories (
    user_id, category_name, subcategory, content, token_count, 
    relevance_score, mode, ...  -- mode MUST be included
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, ...)
`, [userId, category, subcategory, facts, tokenCount, importanceScore, mode, ...]);
</code></pre>
<p><strong>Step 2:</strong> Verify mode is passed to storage</p>
<p>Trace from <code>chat.js</code> ‚Üí <code>orchestrator.js</code> ‚Üí <code>intelligent-storage.js</code>:</p>
<ul>
<li>Where does <code>mode</code> come from?</li>
<li>Is it passed through every function call?</li>
<li>Is it <code>'business-validation'</code> or <code>'business_validation'</code>? (hyphen vs underscore)</li>
</ul>
<p><strong>Step 3:</strong> Verify retrieval uses mode correctly</p>
<pre><code class="language-javascript">// Mode filtering should be:
if (mode &amp;&amp; mode !== 'truth-general') {
  conditions.push(`(mode = $${paramIndex} OR mode = 'truth-general' OR mode IS NULL)`);
  params.push(mode);
} else {
  conditions.push(`(mode = 'truth-general' OR mode IS NULL)`);
}
</code></pre>
<h3>EXACT Fix If Mode Not Stored</h3>
<p>In <code>intelligent-storage.js</code> <code>storeCompressedMemory()</code>:</p>
<pre><code class="language-javascript">async storeCompressedMemory(userId, facts, category, tokenCount, metadata = {}) {
  // Get mode from metadata or default
  const mode = metadata.mode || this.currentMode || 'truth-general';
  
  // Normalize mode format (ensure hyphen not underscore)
  const normalizedMode = mode.replace(/_/g, '-');
  
  console.log(`[INTELLIGENT-STORAGE] Storing with mode: ${normalizedMode}`);
  
  const result = await this.db.query(`
    INSERT INTO persistent_memories (
      user_id, category_name, subcategory, content, token_count, 
      relevance_score, mode, is_current, created_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, true, NOW())
    RETURNING id
  `, [userId, category, 'general', facts, tokenCount, importanceScore, normalizedMode]);
  
  return result.rows[0].id;
}
</code></pre>
<hr>
<h2>üîß FIX 5: MEMORY VISIBILITY (UX-046)</h2>
<h3>Problem Trace</h3>
<pre><code>User: "What do you remember about me?"
Got: Prose summary of memories
Expected: Structured list of stored memories
</code></pre>
<h3>Required Fix Location</h3>
<p><strong>File:</strong> <code>api/core/orchestrator.js</code>
<strong>Location:</strong> Early in <code>processRequest()</code> before normal AI flow</p>
<h3>EXACT Fix Required</h3>
<p>Add detection for memory visibility requests:</p>
<pre><code class="language-javascript">// At the start of processRequest(), after basic setup:

// Memory visibility detection (Innovation #46)
const memoryVisibilityPatterns = [
  /what do you (?:remember|know) about me/i,
  /show (?:me )?(?:my )?memor(?:y|ies)/i,
  /list (?:my |what you )?(?:remember|stored|know)/i,
  /what (?:have you |do you have )(?:stored|saved|remembered)/i,
  /my (?:stored )?(?:memories|information|data)/i
];

const isMemoryVisibilityRequest = memoryVisibilityPatterns.some(p =&gt; p.test(message));

if (isMemoryVisibilityRequest) {
  this.log(`[MEMORY-VISIBILITY] Detected memory visibility request`);
  
  try {
    const memories = await this.pool.query(`
      SELECT id, content, category_name, created_at, relevance_score, mode
      FROM persistent_memories
      WHERE user_id = $1 AND (is_current = true OR is_current IS NULL)
      ORDER BY relevance_score DESC, created_at DESC
      LIMIT 20
    `, [userId]);
    
    if (memories.rows.length === 0) {
      return {
        success: true,
        response: "I don't have any memories stored for you yet. As we talk, I'll remember important facts you share.",
        metadata: { memoryVisibility: true, count: 0 }
      };
    }
    
    // Format as structured list
    let response = `I have ${memories.rows.length} memories stored about you:\n\n`;
    
    memories.rows.forEach((m, i) =&gt; {
      const importance = m.relevance_score &gt;= 0.9 ? '‚≠ê Critical' : 
                        m.relevance_score &gt;= 0.75 ? 'üìå Important' : 'üìù Note';
      response += `${i + 1}. [${m.category_name}] ${m.content}\n`;
      response += `   ${importance} | Stored: ${new Date(m.created_at).toLocaleDateString()}\n\n`;
    });
    
    return {
      success: true,
      response: response.trim(),
      metadata: { memoryVisibility: true, count: memories.rows.length }
    };
  } catch (error) {
    this.log(`[MEMORY-VISIBILITY] Error: ${error.message}`);
    // Fall through to normal processing
  }
}

// ... rest of normal processRequest flow ...
</code></pre>
<hr>
<h2>üîß FIX 6: CROSS-SESSION CONTINUITY (UX-044)</h2>
<h3>Problem Trace</h3>
<pre><code>Test: Store info in session A, query in session B
Result: Memory not found
</code></pre>
<h3>Analysis Required</h3>
<p>This could be:</p>
<ol>
<li>User ID not consistent across sessions</li>
<li>Session-specific storage instead of user-specific</li>
<li>Memory not committed to database before session ends</li>
</ol>
<h3>Verification Steps</h3>
<ol>
<li>Check what <code>userId</code> is used for storage - is it from session or persistent?</li>
<li>Verify INSERT commits immediately (not waiting for session end)</li>
<li>Check if there's session-scoped cache that doesn't persist</li>
</ol>
<h3>Likely Fix Location</h3>
<p><strong>File:</strong> <code>server.js</code> or <code>api/routes/chat.js</code></p>
<p>Verify userId extraction:</p>
<pre><code class="language-javascript">// CORRECT - use persistent user ID
const userId = req.headers['x-user-id'] || req.body.userId || 'anonymous';

// WRONG - using session ID as user ID
const userId = req.sessionId;  // This would break cross-session!
</code></pre>
<hr>
<h2>‚úÖ VERIFICATION CHECKLIST</h2>
<p>After implementing fixes, ALL of these must pass:</p>
<h3>Greeting Length</h3>
<ul>
<li>[ ] <code>"Hello"</code> ‚Üí response.length &lt; 150</li>
<li>[ ] <code>"Hey"</code> ‚Üí response.length &lt; 150</li>
<li>[ ] <code>"Hi there"</code> ‚Üí response.length &lt; 150</li>
<li>[ ] <code>"Good morning"</code> ‚Üí response.length &lt; 150</li>
<li>[ ] Log shows: <code>hard_limited_to_150_chars</code></li>
</ul>
<h3>Supersession</h3>
<ul>
<li>[ ] Store "My salary is $80,000" ‚Üí log shows fingerprint <code>salary:80000</code></li>
<li>[ ] Store "My salary is $95,000" ‚Üí log shows fingerprint <code>salary:95000</code></li>
<li>[ ] First memory marked <code>is_current = false</code></li>
<li>[ ] Query "What's my salary?" ‚Üí returns "$95,000" ONLY</li>
<li>[ ] Old salary ($80,000) NOT in response</li>
</ul>
<h3>Importance Scoring</h3>
<ul>
<li>[ ] Store "I'm allergic to peanuts" ‚Üí log shows <code>CRITICAL keyword "allergic" ‚Üí 0.95</code></li>
<li>[ ] Store "I like pizza" ‚Üí log shows <code>Default score ‚Üí 0.50</code></li>
<li>[ ] Database shows: allergy has <code>relevance_score = 0.95</code></li>
<li>[ ] Database shows: pizza has <code>relevance_score = 0.50</code></li>
<li>[ ] Query "What should you know about feeding me?" ‚Üí allergy mentioned BEFORE pizza</li>
</ul>
<h3>Mode-Aware Retrieval</h3>
<ul>
<li>[ ] Set mode to <code>business-validation</code></li>
<li>[ ] Store "Q3 revenue was $5M" ‚Üí log shows <code>mode: business-validation</code></li>
<li>[ ] Query "How did Q3 go?" in same mode ‚Üí returns "$5M"</li>
</ul>
<h3>Memory Visibility</h3>
<ul>
<li>[ ] Query "What do you remember about me?" ‚Üí returns numbered list</li>
<li>[ ] List shows categories, content, and importance levels</li>
<li>[ ] Does NOT return prose paragraph</li>
</ul>
<h3>Cross-Session</h3>
<ul>
<li>[ ] Session A: Store "My favorite color is blue"</li>
<li>[ ] Session B (new session, same user): Query "What's my favorite color?"</li>
<li>[ ] Returns "blue"</li>
</ul>
<hr>
<h2>üö´ DO NOT</h2>
<ol>
<li><strong>DO NOT</strong> add new features - only fix what's broken</li>
<li><strong>DO NOT</strong> change database schema</li>
<li><strong>DO NOT</strong> modify API contracts</li>
<li><strong>DO NOT</strong> touch working tests (Truth &amp; Integrity, Personality, etc.)</li>
<li><strong>DO NOT</strong> assume code works - verify with logs</li>
<li><strong>DO NOT</strong> merge without ALL verification checks passing</li>
</ol>
<hr>
<h2>üìã IMPLEMENTATION ORDER</h2>
<ol>
<li><strong>Greeting truncation</strong> - Smallest change, immediate impact</li>
<li><strong>Supersession patterns</strong> - Fixes MEM-003 and TRUTH-018</li>
<li><strong>Importance scoring</strong> - Fixes MEM-007</li>
<li><strong>Mode-aware retrieval</strong> - Fixes INJ-008</li>
<li><strong>Memory visibility</strong> - Fixes UX-046</li>
<li><strong>Cross-session</strong> - Fixes UX-044 (may already work after other fixes)</li>
</ol>
<hr>
<h2>üîç REQUIRED: FULL TRACE VERIFICATION</h2>
<p>Before marking any fix complete, you MUST:</p>
<ol>
<li><strong>Trace the code path</strong> from user input to database storage to retrieval to response</li>
<li><strong>Add console.log statements</strong> at each step to verify execution</li>
<li><strong>Check database directly</strong> to verify data is stored correctly</li>
<li><strong>Run the specific test</strong> and verify it passes</li>
<li><strong>Check logs</strong> to confirm the new code paths executed</li>
</ol>
<p>Example trace for greeting:</p>
<pre><code>User sends "Hello"
‚Üí chat.js receives request
‚Üí orchestrator.processRequest() called
‚Üí Query classified as 'simple_short'
‚Üí AI generates response (793 chars)
‚Üí Phase 7.5 truncation triggered
‚Üí Log: "hard_limited_to_150_chars"
‚Üí Response returned (&lt; 150 chars)
</code></pre>
<p>If ANY step doesn't match expected behavior, the fix is incomplete.</p>
<hr>
<p><strong>Priority:</strong> üî¥ CRITICAL
<strong>Estimated Effort:</strong> 4-6 hours with proper verification
<strong>Risk Level:</strong> LOW if traces are followed correctly</p></body></html><!--EndFragment-->
</body>
</html>
Your task is to:
1. Analyze the issue carefully to understand the problem
2. Look through the repository to identify the relevant files that need to be modified
3. Make precise changes to fix the issue
4. Use the Edit tool to modify files directly when needed
5. Be minimal in your changes - only modify what's necessary to fix the issue

After making changes, provide a summary of what you did in this format:

---SUMMARY---
[Your detailed summary of changes, including which files were modified and how]
---END SUMMARY---

Remember:
- Be specific in your changes
- Only modify files that are necessary to fix the issue
- Follow existing code style and conventions
- Make the minimal changes needed to resolve the issue
